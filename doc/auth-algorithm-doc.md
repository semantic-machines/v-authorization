# Алгоритм авторизации: подробное описание

## 1. Основные концепции

### 1.1 Битовая маска прав доступа

Права представлены 8-битным числом:
- **Бит 0** (1): `CanCreate` - право на создание
- **Бит 1** (2): `CanRead` - право на чтение
- **Бит 2** (4): `CanUpdate` - право на обновление
- **Бит 3** (8): `CanDelete` - право на удаление
- **Бит 4** (16): `CantCreate` - запрет на создание
- **Бит 5** (32): `CantRead` - запрет на чтение
- **Бит 6** (64): `CantUpdate` - запрет на обновление
- **Бит 7** (128): `CantDelete` - запрет на удаление

### 1.2 Структура данных в LMDB

```
Muser_id → группа1;права1;группа2;права2;...
Pobject_group_id → субъект1;права1;субъект2;права2;...
Fobject_id → фильтр_id;права

Формат записи (версия 2):
- Права кодируются символами: M(1), R(2), U(4), P(8), m(16), r(32), u(64), p(128)
- Маркеры: X (эксклюзивный), N (игнорировать эксклюзивность)
- Счетчики: M2 означает 2 записи с правом Create

Пример: "user1;MRU;admin;MRUP2X" 
- user1 имеет Create+Read+Update
- admin имеет все права со счетчиком 2 на Delete и эксклюзивным маркером
```

### 1.4 Режимы работы

Система поддерживает несколько режимов:
- **Обычный режим** - максимальная производительность с ранним выходом
- **Режим трассировки** (trace.is_info) - полный обход для отладки
- **Режим ACL** (trace.is_acl) - сбор информации о правах
- **Режим групп** (trace.is_group) - сбор информации о группах

В режимах трассировки ранний выход отключен для сбора полной информации.

- **Субъект** - пользователь или группа пользователей
- **Объект** - защищаемый ресурс или группа ресурсов
- **Membership** - членство в группе (префикс M)
- **PermissionStatement** - связь субъект-объект с правами (префикс P)
- **PermissionFilter** - фильтр ограничений (префикс F)

## 2. Пошаговый алгоритм авторизации

### Шаг 1: Инициализация контекста

```rust
AzContext {
    id: "doc123",
    user_id: "user1",
    request_access: 4, // CanUpdate
    calc_right_res: 0,
    // ... другие поля
}
```

### Шаг 2: Извлечение групп субъекта

```
user1 → Muser1 → "group1;F;group2;F"
         ↓
       group1 → Mgroup1 → "department1;F"
         ↓
    department1 → Mdepartment1 → "company1;F"

Результат: subject_groups = {user1, group1, department1, company1}
```

### Шаг 3: Получение групп объекта первого уровня

```
doc123 → Mdoc123 → "docs_group;F;project_group;F"

first_level_object_groups = [
    {id: "doc123", access: 15},        // 15 = все разрешающие права (C+R+U+D)
    {id: "docs_group", access: 15},    // F в базе декодируется как 15
    {id: "project_group", access: 15}
]
```

**Почему только первый уровень?**

Это чистая оптимизация производительности. В отличие от групп субъекта (которые все нужны для проверки), группы объекта можно проверять лениво:

1. **Сначала проверяются прямые права** - если у субъекта есть права прямо на объект или его непосредственные группы, дальше искать не нужно

2. **Ленивая загрузка дерева** - только если права не найдены на первом уровне, `prepare_obj_group()` начинает рекурсивный обход вглубь

3. **Ранний выход** - как только найдены достаточные права, обход прекращается

**Формат данных в базе:**
```
Mdoc123 → "docs_group;F;project_group;F"
          группа;права;группа;права

Где F = 15 (1111 в двоичном виде = C+R+U+D)
```

### Шаг 4: Проверка фильтров

Фильтры проверяются **только для групп объекта первого уровня**:

```rust
// Только для first_level_object_groups, НЕ для всей иерархии!
for gr_obj in first_level_object_groups.iter() {
    if let (Some(f), _) = get_filter(&gr_obj.id, db) {
        filter_value = f.id;
        request_access_with_filter = request_access & f.access;
        break;  // Берем первый найденный фильтр
    }
}
```

**Важно**: 
- Фильтры НЕ проверяются для групп глубже первого уровня
- Используется первый найденный фильтр (break)
- Если найден фильтр, алгоритм делает ДВА прохода:

```rust
// Первый проход с ограниченными правами
authorize_obj_groups(id, request_access_with_filter);

if !azc.filter_value.is_empty() && права_не_найдены {
    // Второй проход с полными правами
    azc.checked_groups.clear();  // Сброс кеша!
    azc.walked_groups_o.clear();
    authorize_obj_groups(id, request_access);
}
```

### Шаг 5: Авторизация групп объектов

Функция `authorize_obj_groups` проверяет права в следующем порядке:

1. **v-s:AllResourcesGroup** - глобальная группа всех ресурсов
2. **id самого объекта** - прямые права на объект
3. **Рекурсивный обход** через `prepare_obj_group` если права не найдены

#### 5.1 Проверка AllResourcesGroup и прямых прав

```rust
for gr in ["v-s:AllResourcesGroup", id].iter() {
    authorize_obj_group(gr, request_access)
}
```

Извлекаются права из базы:
```
Pv-s:AllResourcesGroup → "admin_group;F;user1;2"
Pdoc123 → "author_group;F"
```

#### 5.2 Кеширование проверенных групп

Для оптимизации используется `checked_groups`:
```rust
if let Some(v) = azc.checked_groups.get(object_group_id) {
    if *v == object_group_access {
        return; // Уже проверяли с такими же правами
    }
}
```

#### 5.4 Проверка прав в authorize_obj_group

При проверке конкретной записи разрешений учитываются ограничения:

```rust
// Ограничения со стороны объекта (из групп объекта)
let obj_restriction_access = object_group_access;  // обычно 15 (все права)

// Ограничения со стороны субъекта (из групп субъекта)  
let subj_restriction_access = subj_gr.access;      // права из иерархии субъекта

// Расчет реальных прав из записи PermissionStatement
let permission_access = if permission.access > 15 {
    // Применение запрещающих прав (если есть)
    (((permission.access & 0xF0) >> 4) ^ 0x0F) & permission.access
} else {
    permission.access
};

// Финальная проверка для каждого запрашиваемого права
for access in [1, 2, 4, 8] {  // C, R, U, D
    if (request_access & access & obj_restriction_access & subj_restriction_access) != 0 {
        calc_bits = access & permission_access;
        if calc_bits > 0 {
            azc.calc_right_res |= calc_bits;  // Накопление прав
        }
    }
}
```

Это позволяет ограничивать права на любом уровне иерархии групп.

### Шаг 7: Расчет итоговых прав и финальная проверка

#### 7.1 Накопление прав

```rust
calc_right_res |= найденные_права  // Операция OR
```

Права из разных путей доступа **суммируются**. Это ключевая особенность системы!

#### 7.2 Ранний выход

**ВАЖНО**: Как только `calc_right_res & request_access == request_access`, происходит ранний выход:

```rust
if (azc.calc_right_res & request_access) == request_access {
    if !trace.is_info && !trace.is_group && !trace.is_acl {
        return Ok(true);  // ВЫХОД!
    }
}
```

#### 7.3 Финальная проверка

После завершения всех проверок вызывается `final_check`:

```rust
fn final_check(azc: &mut AzContext) -> bool {
    if azc.is_need_exclusive_az && azc.is_found_exclusive_az {
        true  // Эксклюзивный доступ найден
    } else {
        !azc.is_need_exclusive_az  // Эксклюзивный доступ не требуется
    }
}
```

Это гарантирует, что эксклюзивные ограничения соблюдены.

## 3. Примеры

### Пример 1: Успешная авторизация

```
Пользователь: john (входит в managers_group)
Ресурс: report.docx (входит в documents_group)
Запрос: CanRead (2)

1. subject_groups = {john, managers_group}
2. Проверяем Pdocuments_group:
   - managers_group;6 (Read + Update)
3. calc_right_res = 6
4. 6 & 2 == 2 ✓ Доступ разрешен
```

### Пример 2: Отказ в доступе

```
Пользователь: intern (входит в interns_group)
Ресурс: salary.xlsx (входит в hr_docs_group)
Запрос: CanUpdate (4)

1. subject_groups = {intern, interns_group}
2. Проверяем Phr_docs_group:
   - hr_group;F
   - interns_group;2 (только Read)
3. calc_right_res = 2
4. 2 & 4 != 4 ✗ Доступ запрещен
```

## 4. Проблемы с запрещающими правами

### Проблема 1: Неполный список проверяемых битов

```rust
// В authorize_obj_group.rs
for i_access in ACCESS_8_LIST.iter() {  // [1, 2, 4, 8]
    let access = *i_access;
    // Запрещающие биты [16, 32, 64, 128] НЕ проверяются!
}
```

### Проблема 2: Несоответствие битов при проверке

```rust
// Пользователь запрашивает разрешающее право
request_access = 4 (CanUpdate)

// В базе запрещающее право  
permission.access = 64 (CantUpdate)

// Проверка в цикле
if (request_access & access & ...) != 0 {
    // 4 & 64 = 0, условие не выполнится!
}
```

Запрещающие и разрешающие права находятся в разных битовых позициях:
- CanCreate (1) ↔ CantCreate (16)
- CanRead (2) ↔ CantRead (32)
- CanUpdate (4) ↔ CantUpdate (64)
- CanDelete (8) ↔ CantDelete (128)

### Проблема 3: Ранний выход (главная проблема!)

```rust
// Как только нашли нужные права - ВЫХОД
if (azc.calc_right_res & request_access) == request_access {
    return Ok(true);  // Последующие записи с запретами не проверяются!
}
```

### Пример неработающего запрета

```
Порядок записей в базе:
1. Pproject_group → "developers;F"     // Полные права
2. Psecurity_group → "developers;p"    // CantDelete (128)

Алгоритм:
1. Проверяет project_group → находит все права → ВЫХОД!
2. security_group с запретом никогда не проверяется

Результат: запрет не работает
```

### Почему запреты работают только внутри одной записи

```rust
let permission_access = if permission.access > 15 {
    // Запреты применяются ТОЛЬКО к правам из этой же записи
    (((permission.access & 0xF0) >> 4) ^ 0x0F) & permission.access
} else {
    permission.access
};
```

Пример: права "MRUp" (7 + 128) = 135
1. Извлекаем запреты: 128 >> 4 = 8 (Delete)
2. Инвертируем: 8 ^ 15 = 7 (разрешены C,R,U)
3. Применяем: 135 & 7 = 7 (остаются только C,R,U)

Но это работает только внутри одной записи PermissionStatement!

## 5. Эксклюзивные права

### Механизм работы

Эксклюзивные права ограничивают доступ только определенными группами:

```
company1_membership:
  v-s:memberOf internal_docs_group
  v-s:resource company1
  v-s:isExclusive true // Маркер 'X'
```

### Маркеры

- **'X' (M_IS_EXCLUSIVE)** - включает эксклюзивный режим для группы
- **'N' (M_IGNORE_EXCLUSIVE)** - позволяет игнорировать эксклюзивные ограничения для конкретной ветки

### Алгоритм проверки

1. **Установка флага необходимости** - при обходе групп субъекта, если найден маркер 'X', устанавливается `is_need_exclusive_az = true`

2. **Поиск эксклюзивного доступа** - при обходе групп объекта ищется подтверждение эксклюзивного доступа:
   ```rust
   // На уровне 0 (первый уровень групп объекта)
   if level == 0 {
       // Если есть группы с суффиксом "_group"
       if group.id.contains("_group") {
           is_contain_suffix_group = true;
       }
       
       // Если это последняя группа и нет "_group" групп
       if idx == последняя && !is_contain_suffix_group {
           is_found_exclusive_az = true; // Системный объект
       }
       
       // Специальная группа TTL
       if group.id.contains("cfg:TTLResourcesGroup") {
           is_found_exclusive_az = true;
       }
   }
   
   // Проверка пересечения групп субъекта и объекта
   if subject_groups.contains(&group.id) && 
      subject_groups[group.id].marker == 'X' {
       is_found_exclusive_az = true;
   }
   ```

3. **Финальная проверка** - доступ разрешается только если:
   - `is_need_exclusive_az == false` (нет эксклюзивных ограничений) ИЛИ
   - `is_need_exclusive_az == true && is_found_exclusive_az == true`

### Особенности

- Группы с маркером 'X' пропускаются при рекурсивном обходе (`continue`)
- Если у объекта нет групп или только системные группы → доступ разрешен
- Пустой список групп на уровне 0 → `is_found_exclusive_az = true`

### Важное предупреждение

```
ВАЖНО: При наличии хотя бы одной записи с v-s:isExclusive, пользователи теряют ВСЕ права, 
кроме прав на онтологию и прав через эксклюзивные группы!
```

## 6. Фильтры разрешений

### Назначение

Фильтры - это механизм временного ограничения прав на ресурсы. В отличие от документации, в коде реализован упрощенный механизм.

### Как работают фильтры в коде

```
filter1:
  rdf:type v-s:PermissionFilter
  v-s:permissionObject resource1  // На какой ресурс ограничение
  v-s:resource filter_id         // ID фильтра
  v-s:canRead true              // Маска разрешенных операций
```

### Алгоритм работы

1. При проверке прав ищется фильтр для групп объекта (Fdocs_group)
2. Если фильтр найден, делается **два прохода**:
   - **Первый проход**: `request_access & filter_access` (с ограничениями)
   - **Второй проход**: `request_access` (без ограничений, если первый не дал результата)

### Пример

```
1. Создаем фильтр Fdocs_group → "filter1;2" (только Read)
2. Пользователь запрашивает Update (4) на документ в docs_group
3. Первый проход: 4 & 2 = 0 (нет прав)
4. Второй проход: проверка с полными правами

Это позволяет иметь "обычные" права через второй проход,
даже если фильтр их ограничивает.
```

### Отличие от документации

В документации описан механизм с `v-s:useFilter` для создания исключений, но в коде это не реализовано. Вместо этого используется двухпроходный алгоритм.

## 7. Оптимизации и их влияние

### Кеширование
- Результаты могут кешироваться в отдельной LMDB базе
- Ускоряет повторные запросы

### Ранний выход
- Ускоряет поиск разрешений
- **Ломает** запрещающие права

### Ограничение рекурсии
- Максимальная глубина: 32 уровня
- Защита от циклических ссылок

## 8. Выводы

### Архитектурные решения

1. **Оптимизация для скорости** - система построена для быстрого нахождения любого разрешения
2. **Модель "любое разрешение побеждает"** - права накапливаются через OR из всех путей доступа
3. **Ранний выход** - критичен для производительности, но убивает запрещающие права
4. **Запрещающие права** - работают только локально внутри одной записи

### Практические рекомендации

Для реализации ограничений используйте:

1. **Фильтры** - для временных ограничений, но помните про двухпроходный алгоритм
2. **Эксклюзивные группы** - для изоляции данных между организациями
3. **Тщательное проектирование** - размещайте права так, чтобы не полагаться на запреты

### Важные особенности

- Порядок проверки групп может быть непредсказуемым
- Кеширование может влиять на порядок обработки
- Системные объекты (без "_group") имеют особую обработку
- Пустые группы на уровне 0 считаются системными

### Итог

Система авторизации VEDA - это компромисс между производительностью и гибкостью. Понимание её ограничений критично для правильного проектирования схемы безопасности.